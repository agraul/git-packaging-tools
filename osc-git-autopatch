#!/usr/bin/env python
#
# Copyright (c) 2017, SUSE Linux Products GmbH
#
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without modification,
# are permitted provided that the following conditions are met:
#
# Redistributions of source code must retain the above copyright notice,
# this list of conditions and the following disclaimer. Redistributions in binary
# form must reproduce the above copyright notice, this list of conditions and the
# following disclaimer in the documentation and/or other materials provided with
# the distribution.
#
# Neither the name of the SUSE Linux Products GmbH nor the names of its contributors
# may be used to endorse or promote products derived from this software without
# specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
# OF THE POSSIBILITY OF SUCH DAMAGE.

'''
 Author: Bo Maryniuk <bo@suse.de>

  This tool helps to:
  1. Format patches from Git the way it has a minimal impact on
     the changes in the future
 
  2. Update patches to the current package source

  3. Detect content differences, if the filename is still the same

  4. Generate include message for .changes logfile
'''

import os
import re
import sys
import shutil
import logging
import argparse
import datetime
import textwrap

try:
    import yaml
except ImportError as ex:
    yaml = None

try:
    import git
except ImportError as ex:
    git = None

try:
    import spec
except ImportError as ex:
    spec = None

try:
    import whatthepatch as wtp
except ImportError as ex:
    wtp = None


ORDERING_FILE = 'patches.orders.txt'
CHANGES_FILE = 'patches.changes.txt'

log = logging.getLogger('osc-gitpak')


class SpecException(Exception):
    '''
    Spec Exception
    '''


class GitOpException(Exception):
    '''
    Exception on Git operation
    '''


class Git2OSCMixer(object):
    '''
    Scenario processor.
    '''
    def __init__(self, config, log):
        self._scenario = config
        self.log = log
        self._git = GitProcess(self._scenario.get('git'), log=log,
                               flush_patches_dir=self._scenario.get('package', {}).get('flush-old-patches', False))
        self._sp = SpecProcess(self._scenario['package'], log=log)

        self.DIRECTIVES = {
            'patch': {
                'apply': self.__block_patch_apply,
                'define': self.__block_patch_define,
            }
        }

    def update_specfile(self, path, blockset):
        '''
        Replace block in the marked template.

        :param snippet:
        :param directive:
        :return:
        '''
        with open(path) as fh:
            data = fh.read()

        out = []
        for block, directive in blockset:
            _data = data.split('# @@ {0}: {1} >>'.format(self._sp.TAG, directive))
            out.append(_data[0].strip())
            out.append('')
            out.append(block)
            out.append('')
            out.append(_data[1].split('# @@ {0}: {1} <<'.format(self._sp.TAG, directive))[-1].strip())
            data = os.linesep.join(out)
            out = []

        fh = open(path + ".new", "w")
        fh.write(data)
        fh.close()
        self.log.debug('Updated specfile with the new patch definitions')


    def __block(self, directive):
        '''
        Get snippet of the block
        :param directive:
        :return:
        '''
        snippet = ['# @@ {0}: {1} >>'.format(self._sp.TAG, directive)]

        if directive == 'patch.define':
            for p_idx, p_ref, p_file, p_doc, p_cond in self._sp.get_patch_map():
                snippet.append(p_doc)
                snippet.append('{0: <16}{1}'.format((p_ref + ':'), p_file))
        elif directive == 'patch.apply':
            for exc in self._sp.get_patch_executors():
                snippet.append(exc)

        snippet.append('# @@ {0}: {1} <<'.format(self._sp.TAG, directive))
        return os.linesep.join(snippet)

    def __block_patch_apply(self):
        '''
        Returns a snippet for applying patches
        :return:
        '''
        return self.__block('patch.apply')

    def __block_patch_define(self):
        '''
        Returns a snippet for defining patches
        :return:
        '''
        return self.__block('patch.define')

    def update_patch_files(self, new, changed, removed):
        '''
        Update patch files in the packages.
        This will remove deleted, add new and update changed patches.

        :return:
        '''
        for f_name in new + changed:
            shutil.copy(os.path.join(self._git._config['patches-dir'], f_name),
                        os.path.abspath(os.path.dirname(self._sp._spec_path)))
        for fname in removed:
            fname = os.path.join(os.path.dirname(self._sp._spec_path), fname)
            if os.path.exists(fname):
                os.unlink(fname)

        if new or changed:
            self.log.debug('Moved {0} patch{1}'.format(len(new + changed), 'es' if len(changed + new) > 1 else ''))
        if removed:
            self.log.debug('Deleted {0} patch{1}'.format(len(removed), 'es' if len(removed) > 1 else ''))

    def check_spec_compat(self):
        '''
        Check if spec file is compatible.
        :return:
        '''
        compat = 0
        for line in self._sp._spec_src:
            for directive in ['patch.apply', 'patch.define']:
                directive = '@@ {0}: {1} '.format(self._sp.TAG, directive)
                for block in ['>>', '<<']:
                    if directive + block in line:
                        compat += 1
        return compat == 4

    def process(self):
        '''
        Process.
        :return:
        '''
        if not self.check_spec_compat():
            raise Exception('Spec file is not compatible for this process.')
        new_patches, changed_patches, removed_patches = self.get_diff_patches()
        self.log.debug('Found {0} new, {1} changed and {2} removed patches'.format(
            len(new_patches), len(changed_patches), len(removed_patches)))

        for patchname in changed_patches:
            self.log.debug('Changed patch: "{0}"'.format(patchname))
        for patchname in new_patches:
            self._sp.add_patch(patchname, doc=None, condition=None)  # TODO: Get doc and conditions from the doc
        for patchname in removed_patches:
            self._sp.remove_patch(patchname)

        self.update_specfile(self._sp._spec_path,
                             ((self.__block_patch_define(), 'patch.define'),
                              (self.__block_patch_apply(), 'patch.apply'),))
        self.update_patch_files(new=new_patches, changed=changed_patches, removed=removed_patches)

    def _is_diff_patch(self, a_patch, b_patch, ignore_commit_id=True):
        '''
        Finds out if patches are different.

        :param a_patch:
        :param b_patch:
        :return:
        '''
        def _get_body(data):
            return data.split('@@')[-1].split('\n-- \n')[0].strip()

        a_patch, b_patch = list(a_patch), list(b_patch)
        if len(a_patch) != len(b_patch):
            return True

        # header, changes, body = set
        for a_p_set, b_p_set in zip(a_patch, b_patch):
            a_body, b_body = _get_body(a_p_set[-1]), _get_body(b_p_set[-1])
            if a_body != b_body:
                return True

        return False

    def get_diff_patches(self):
        '''
        Get difference in patches between the Git repo and the package content.
        :return:
        '''
        n_pt, c_pt, r_pt = [], [], []  # New, changed, removed
        pkg_patches = self._sp.get_patch_map()
        git_patches = self._git.get_patch_map()

        self.log.debug('Found {0} patches defined in the "{1}" spec file'.format(
            len(pkg_patches), self._sp._spec_path))
        self.log.debug('Found {0} patches defined in the Git repository at "{1}" for "{2}" branch'.format(
            len(git_patches), self._git._config['repo-full-path'], self._git._config['branch']))

        pkg_filenames = [p_set[2] for p_set in pkg_patches]
        for p_set in git_patches:
            c_id, p_path = p_set
            fname = os.path.basename(p_path)
            if fname not in pkg_filenames:
                self.log.debug('New patch detected: "{0}"'.format(fname))
                n_pt.append(fname)
                continue
            # Do diff check here
            git_patch = os.path.join(self._git._config['patches-dir'], fname)
            with open(git_patch) as ph:
                git_p_patch = wtp.parse_patch(ph.read())

            pkg_patch = os.path.join(os.path.dirname(self._sp._spec_path), fname)
            with open(pkg_patch) as ph:
                pkg_p_patch = wtp.parse_patch(ph.read())
            if self._is_diff_patch(git_p_patch, pkg_p_patch):
                self.log.debug('Changed patch detected: "{0}"'.format(fname))
                c_pt.append(fname)

        git_filenames = [os.path.basename(p_set[1]) for p_set in git_patches]
        for p_set in pkg_patches:
            idx, ref, fname, doc, cond = p_set
            if fname not in git_filenames:
                self.log.debug('Removed patch detected: "{0}"'.format(fname))
                r_pt.append(fname)

        return n_pt, c_pt, r_pt

    def _process(self):
        repo = self._git.clone()
        self._git.fetch(repo)
        self._git.checkout(repo)

        patches_dir = os.path.join(self._scenario['git']['repo-full-path'], '.patches')
        if not os.path.exists(patches_dir):
            os.makedirs(patches_dir)
        self._git._config['patches-dir'] = patches_dir  # Not good.

        patches = self._git.make_patches(repo, tag='vTest')


class SpecProcess(object):
    '''
    Spec parsing, extracting objects etc.

    '''
    TAG = 'osc-gitpak'

    def __init__(self, config, log):
        self._config = config
        self._spec_path = config['spec']
        self._spec_changelog = os.path.join(os.path.dirname(self._spec_path),
                                            os.path.basename(self._spec_path).split(".")[0] + ".changes")
        if not os.path.exists(self._spec_changelog):
            raise FileNotFoundError('Pak: Changelog "{0}" was not found.'.format(self._spec_changelog))
        self.log = log
        self._spec = spec.Spec.from_file(self._spec_path)
        self._spec_src = open(self._spec_path).read().split(os.linesep)
        self._patch_map = []

    def _get_patch_comment(self, patch_file):
        '''
        Get a comment for the particular patch file.

        :param patch_file:
        :return:
        '''
        comment = []
        idx = 0
        for line in self._spec_src:
            if patch_file in line:
                break
            idx += 1
        for idx in reversed(range(idx)):
            line = self._spec_src[idx]
            if line.startswith('#') and '@@ {0}'.format(self.TAG) not in line:
                comment.append(line)
            else:
                break

        return os.linesep.join(reversed(comment))

    def get_patch_map(self):
        '''
        Get spec patch map along with the comments to each patch,
        assuming the comment belongs to the patch below it and has
        no empty lines in between.
        :return:
        '''
        if not self._patch_map:
            conditionals = self._parse_patch_executors()
            for patch_index, patch_name in enumerate(self._spec.patches_dict, 1):
                patch_ref = 'Patch{0}'.format(patch_index)
                patch_name = self._spec.patches_dict[patch_ref]
                self._patch_map.append((patch_index, patch_ref, patch_name,
                                        self._get_patch_comment(patch_name),
                                        conditionals.get('{0}'.format(patch_index))),)

        return self._patch_map

    def remove_patch(self, filename):
        '''
        Remove patch from the patchmap.

        :param filename:
        :return:
        '''
        p_map = []
        p_idx = 0
        for p_set in self._patch_map:
            idx, ref, fn, doc, cond = p_set
            if fn != filename:
                p_idx += 1
                p_map.append((p_idx, 'Patch{0}'.format(p_idx), fn, doc, cond),)
        self._patch_map = p_map
        self.log.debug('Removed "{0}"'.format(filename))

    def add_patch(self, filename, doc=None, condition=None):
        '''
        Add patch to the specfile patchmap.

        :param filename:
        :param doc:
        :return:
        '''
        def format_doc(msg):
            wrapper = textwrap.TextWrapper(initial_indent='# ',
                                           subsequent_indent='# ',
                                           break_on_hyphens=True,
                                           break_long_words=True,
                                           fix_sentence_endings=False,
                                           width=80)
            return os.linesep.join(wrapper.wrap(' '.join([item.strip() for item in msg.split(os.linesep)])))
        p_idx = len(self.get_patch_map()) + 1
        self._patch_map.append((p_idx, 'Patch{0}'.format(p_idx),
                                filename, format_doc(doc) if doc else '# N/A', condition),)
        self.log.debug('Added "{0}"'.format(filename))

    def _parse_patch_executors(self):
        '''
        Parse patch executors from the spec file.

        :return:
        '''
        # Get conditions
        cnd_execs = {}
        for chunk in os.linesep.join(self._spec_src).split('%endif'):
            chunk = chunk.split('%if ')[-1]
            if '%patch' in chunk:
                chunk = [item for item in chunk.split(os.linesep) if item]
                if chunk:
                    condition = chunk.pop(0)
                    for patch_ref in chunk:
                        patch_ref = re.sub(r'\D', '', patch_ref.split(' ')[0])
                        cnd_execs[patch_ref] = condition
        return cnd_execs

    def get_patch_executors(self):
        '''
        Return a snippet of patch executors.
        :return:
        '''
        executors = []
        for idx, tag, filename, doc, condition in self.get_patch_map():
            if condition:
                executors.append('%if {0}'.format(condition))
                executors.append('%patch{0} -p1'.format(idx))
                executors.append('%endif')
            else:
                executors.append('%patch{0} -p1'.format(idx))

        return executors


class GitProcess(object):
    '''
    Git commands.
    '''
    IDX_PATCHES_FILE = '.patches-order'
    LOG_PATCHES_FILE = '.patches-changes'

    def __init__(self, config, log, flush_patches_dir=False):
        self._config = config
        self.log = log
        if not self._config:
            raise Exception('Git is not configured!')

        for keycheck in ['repo-path', 'branch', 'url']:
            if keycheck not in self._config:
                raise Exception('The "{0}" directive is missing'.format(keycheck))
        name = self.get_repo_name(self._config['url'])
        self._config['repo-full-path'] = os.path.join(self._config['repo-path'], name)
        self._patch_map = []

        patches_dir = os.path.join(self._config['repo-full-path'], '.patches')
        if not os.path.exists(patches_dir):
            os.makedirs(patches_dir)
        self._config['patches-dir'] = patches_dir
        if flush_patches_dir:
            self._flush_patches_dir()

    def _flush_patches_dir(self):
        '''
        Flush patches directory.
        :return:
        '''
        for file_name in os.listdir(self._config['patches-dir']):
            os.unlink(os.path.join(self._config['patches-dir'], file_name))

    def get_repo_name(self, url):
        '''
        Get repository name from the url.
        :param url:
        :return:
        '''
        return url.split('/')[-1].split('.')[0]

    def clone(self):
        '''
        Prepare sources from the repository.
        '''
        if not os.path.exists(self._config['repo-full-path']):
            os.makedirs(self._config['repo-full-path'])
            git.Repo.clone_from(self._config['url'], self._config['repo-full-path'])

        return git.Repo(self._config['repo-full-path'])

    def checkout(self, repo, branch_name=None):
        '''
        Checkout an appropriate branch.

        :param branch:
        :return:
        '''
        branch_name = (branch_name or self._config['branch']).split("/")[-1]
        for remote in repo.remotes.origin.refs:
            if remote.name.split("/")[-1] == branch_name:
                repo.create_head(branch_name).checkout()
                repo.git.pull('origin', branch_name)

    def fetch(self, repo):
        '''
        Fetch the repo objects

        :param repo:
        :return:
        '''
        for remote in repo.remotes:
            remote.fetch()
            self.log.debug('Git repo fetched "{0}" remote'.format(remote.name))

    def _unique(self, fname):
        '''
        Change name to the unique, in case it isn't.

        :param fname:
        :param use:
        :return:
        '''
        fname = fname.split('.')
        if '-' not in fname[0]:
            fname[0] = '{0}-{1}'.format(fname[0], 1)
        else:
            chnk = fname[0].split('-')
            try:
                fname[0] = '{0}-{1}'.format('-'.join(chnk[:-1]), int(chnk[-1]) + 1)
            except ValueError as err:
                fname[0] = '{0}-{1}'.format(fname[0], 1)  # Filename is not in "str-int", but "str-str".

        return '.'.join(fname)

    def _remove_filename_order(self, filename):
        '''
        Remove order of the patch filename.

        Git formats patches: XXXX-filename.patch
        This function removes the "XXXX-" part, if any.
        '''
        b_fname = os.path.basename(filename)
        dir_name = os.path.dirname(filename)

        ordnum = b_fname.split('-')[0]
        if ordnum and not re.sub(r'[0-9]', '', ordnum):
            new_filename = os.path.join(dir_name, b_fname.split('-', 1)[-1]).lower()
            ordnum = int(ordnum)
        else:
            new_filename = filename
            ordnum = None

        return ordnum, filename, new_filename

    def _remove_body_order(self, src_file, dst_file, use_unique=False):
        '''
        Remove subject inside the patch.

        Git format patches inside with the following subject format:
        Subject: [PATCH X/Y] .........

        This function removes [PATCH X/Y] part, if any. In Git format-patches one can
        add "-N" flag, so then subject won't have these numbers, but just "[PATCH]".
        In this case we leave it out.
        '''

        if os.path.exists(dst_file) and not use_unique:
            raise IOError('the file {0} exists'.format(dst_file))

        if use_unique:
            dst_file = self._unique(dst_file)
        dst = open(dst_file, 'w')
        for fline in open(src_file).read().split(os.linesep):
            fline_tk = re.split(r'\s+\[PATCH \d+/\d+\]\s+', fline)
            if len(fline_tk) == 2 and fline_tk[0] == 'Subject:':
                fline = ' [PATCH] '.join(fline_tk)
            dst.write('{0}\n'.format(fline))
        dst.close()
        if os.path.exists(src_file):
            os.unlink(src_file)

    def _pack_order(self, paths):
        '''
        Remove order from the patches (subject, body, filename etc) and create an index file nearby.
        :param paths:
        :return:
        '''

        n_paths = []
        idx_file = open(os.path.join(self._config['patches-dir'], self.IDX_PATCHES_FILE), 'w')
        idx_file.write('# @@ {0}: patch.define >>\n'.format(SpecProcess.TAG))
        for commit_id, patch_pth in paths:
            idx, current_fname, new_fname = self._remove_filename_order(patch_pth)
            self._remove_body_order(current_fname, new_fname)
            idx_file.write('Patch{0: <10}{1}\n'.format(str(idx) + ':', os.path.basename(new_fname)))
            n_paths.append((commit_id, new_fname,))
        idx_file.write('# @@ {0}: patch.define <<\n'.format(SpecProcess.TAG))
        idx_file.write('# ---\n')
        idx_file.write('# @@ {0}: patch.apply >>\n'.format(SpecProcess.TAG))
        for idx in range(len(paths)):
            idx_file.write('%patch{0} -p1\n'.format(idx + 1))
        idx_file.write('# @@ {0}: patch.apply <<\n'.format(SpecProcess.TAG))
        idx_file.close()

        return n_paths

    def _get_physical_patch_id(self, path):
        '''
        Extracts a physical ID from the patch file.

        :param path:
        :return:
        '''
        commit_id = None
        if not os.access(path, os.R_OK):
            raise GitOpException("Unable to access '{0}' file".format(path))
        for line in open(path).readlines():
            line = line.strip().lower().split(' ')
            if len(line) > 1 and len(line[1]) == 40:
                commit_id = line[1]
                break

        return commit_id

    def get_patch_map(self, tag=None, clean=False):
        '''
        Get map of the patches in this repo.
        :return:
        '''
        if self._patch_map and not clean:
            return self._patch_map

        tag = tag or self._config.get('tag', None)
        if not tag:
            raise GitOpException('Tag needs to be specified till what to generate patches. '
                                 'Otherwise I will flood you!')
        repo = self.clone()
        self.log.debug('Git repo initialized: "{0}"'.format(repo.git_dir))
        self.fetch(repo)
        self.log.debug('Git repo fetched to {0} refs and {1} tags.'.format(len(repo.refs), len(repo.tags)))
        self.checkout(repo)
        self.log.debug('Git repo checked out: "{0}"'.format(repo.active_branch))
        self._patch_map = self.make_patches(repo, tag)
        self.log.debug('Git repo found {0} patches from "{1}" tag'.format(len(self._patch_map), tag))

        return self._patch_map

    def make_patches(self, repo, tag, path=None):
        '''
        Make raw patches.

        :param repo:
        :param tag:
        :param path:
        :return:
        '''
        path = path or self._config.get('patches-dir', './')
        paths = repo.git.format_patch(tag, '-o', path).split('\n')
        for idx, p_pth in enumerate(paths):
            paths[idx] = (self._get_physical_patch_id(p_pth), p_pth)

        paths = self._pack_order(paths)  # Update names
        return paths

    def gen_changelog(self, repo, patches):
        '''
        Generate chanelog.

        :param repo:
        :param patches:
        :return:
        '''
        def _format_message(msg):
            '''
            Format message from anything to a changelog-compatible.

            :param msg:
            :return:
            '''
            wrapper = textwrap.TextWrapper(initial_indent='- ',
                                           subsequent_indent='  ',
                                           break_on_hyphens=True,
                                           break_long_words=True,
                                           fix_sentence_endings=False,
                                           width=67)
            out = []
            for line in msg.split('\n'):
                line = line.strip()
                if not line:
                    continue
                if not line.endswith("."):
                    line += '.'
                out.append(line[0].upper() + line[1:])
            return '\n'.join(wrapper.wrap(' '.join(out)))

        changelog = []
        for commit_id, patchfile in patches:
            commit = repo.commit(commit_id)
            changelog.append(_format_message(commit.message))

        changelog_file = open(os.path.join(self._config['patches-dir'], self.LOG_PATCHES_FILE), 'w')
        changelog_file.write(os.linesep.join(changelog) + os.linesep)
        changelog_file.close()

        return changelog


def get_cli_params():
    '''
    Parse CLI parameters.
    :return:
    '''
    parser = argparse.ArgumentParser(description='Git-based patch automation service for packages')
    parser.add_argument('-r', '--run', action='store_const', const=True,
                        help='Perform the patching')
    parser.add_argument('-q', '--quiet', action='store_const', const=True,
                        help='Stay silent, no logging, no output.')
    parser.add_argument('-g', '--repo', action='store', const=None,
                        help='Git repository to generate patches from')
    parser.add_argument('-f', '--format', action='store', const=None,
                        help='specify tag or range of commits for patches to be formatted')
    parser.add_argument('-s', '--spec', action='store', const=None,
                        help='specify package spec file')
    parser.add_argument('-v', '--version', action='store_const', const=True,
                        help='show version')
    parser.add_argument('-c', '--config', action='store', const=None,
                        help='Automation config file')
    parser.add_argument('-d', '--debug', action='store_const', const=True,
                        help='Debug (show actual traceback)')
    args = parser.parse_args()
    return args, parser


def setup_logger(args):
    '''
    Setup logger.

    :param level:
    :return:
    '''
    level = (args.debug and logging.DEBUG) or (not args.quiet and logging.INFO) or logging.NOTSET
    channel = logging.StreamHandler(sys.stdout)
    channel.setLevel(level)
    channel.setFormatter(logging.Formatter('%(asctime)s %(name)s [%(levelname)s] - %(message)s'))
    log.setLevel(level)
    log.addHandler(channel)


def main():
    '''
    Main app.
    '''
    VERSION = '0.1'
    args, parser = get_cli_params()
    setup_logger(args)
    try:
        log.info('Start')
        # Check environment
        for mod, mod_descr in [(yaml, 'YAML'), (wtp, 'Patch parser (whatthepatch)'),
                               (git, 'python-git (GitPython)')]:
            log.debug('Checking for {0} module is installed'.format(mod_descr))
            if mod is None:
                raise Exception("{0} module is not installed.".format(mod_descr))

        if args.version:
            print("Version: {0}".format(VERSION))
            sys.exit(1)

        if not args.run:
            parser.print_help()
            sys.exit(1)

        config_filename = args.config or '_gitpak'
        log.debug('Looking for "{0}" config filename'.format(config_filename))
        config = yaml.load(open(config_filename).read())
        if not config:
            log.debug('Config is empty. Exiting.')
            parser.print_help()
            sys.exit(1)
        else:
            mixer = Git2OSCMixer(config, log)
            log.debug('Processing the package')
            mixer.process()
        log.info('Finished')
    except Exception as ex:
        log.fatal("Critical error: {0}".format(ex))
        if args.debug:
            raise


if __name__ == '__main__':
    main()
