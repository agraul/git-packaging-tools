#!/usr/bin/env python
#
# Copyright (c) 2017, SUSE Linux Products GmbH
#
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without modification,
# are permitted provided that the following conditions are met:
#
# Redistributions of source code must retain the above copyright notice,
# this list of conditions and the following disclaimer. Redistributions in binary
# form must reproduce the above copyright notice, this list of conditions and the
# following disclaimer in the documentation and/or other materials provided with
# the distribution.
#
# Neither the name of the SUSE Linux Products GmbH nor the names of its contributors
# may be used to endorse or promote products derived from this software without
# specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
# OF THE POSSIBILITY OF SUCH DAMAGE.

'''
 Author: Bo Maryniuk <bo@suse.de>

  This tool helps to:
  1. Format patches from Git the way it has a minimal impact on
     the changes in the future
 
  2. Update patches to the current package source

  3. Detect content differences, if the filename is still the same

  4. Generate include message for .changes logfile
'''

import os
import sys
import re
import argparse
import shutil
import textwrap

try:
    import yaml
except ImportError as ex:
    yaml = None

try:
    import git
except ImportError as ex:
    git = None

try:
    import spec
except ImportError as ex:
    spec = None

try:
    import whatthepatch as wtp
except ImportError as ex:
    wtp = None


ORDERING_FILE = 'patches.orders.txt'
CHANGES_FILE = 'patches.changes.txt'


class Scenario(object):
    '''
    Scenario processor.
    '''
    def __init__(self, scenario_path):
    def __init__(self, config):
        self._scenario = config
        self._git = GitProcess(self._scenario.get('git'),
                               flush_patches_dir=self._scenario.get('package', {}).get('flush-old-patches', False))
        self._sp = SpecProcess(self._scenario['package']['spec'])

    def process(self):
        '''
        Process.
        :return:
        '''
        self._sp.add_patch('my-very-cool.patch', doc='Test doc', condition='%{defined}')
        for p_idx, p_ref, p_file, p_doc, p_cond in self._sp.get_patch_map():
            print(p_doc, p_idx)
            print(p_ref, p_file)

    def _is_diff_patch(self, a_patch, b_patch, ignore_commit_id=True):
        '''
        Finds out if patches are different.

        :param a_patch:
        :param b_patch:
        :return:
        '''
        def _get_body(data):
            return data.split('@@')[-1].split('\n-- \n')[0].strip()

        a_patch, b_patch = list(a_patch), list(b_patch)
        if len(a_patch) != len(b_patch):
            return True

        # header, changes, body = set
        for a_p_set, b_p_set in zip(a_patch, b_patch):
            a_body, b_body = _get_body(a_p_set[-1]), _get_body(b_p_set[-1])
            if a_body != b_body:
                return True

        return False

    def get_diff_patches(self):
        '''
        Get difference in patches between the Git repo and the package content.
        :return:
        '''
        n_pt, c_pt, r_pt = [], [], []  # New, changed, removed
        pkg_patches = self._sp.get_patch_map()
        git_patches = self._git.get_patch_map()

        pkg_filenames = [p_set[2] for p_set in pkg_patches]
        for p_set in git_patches:
            c_id, p_path = p_set
            fname = os.path.basename(p_path)
            if fname not in pkg_filenames:
                n_pt.append(fname)
                print("Added:", fname)
                continue
            # Do diff check here
            git_patch = os.path.join(self._git._config['patches-dir'], fname)
            with open(git_patch) as ph:
                git_p_patch = wtp.parse_patch(ph.read())

            pkg_patch = os.path.join(os.path.dirname(self._sp._spec_path), fname)
            with open(pkg_patch) as ph:
                pkg_p_patch = wtp.parse_patch(ph.read())
            if self._is_diff_patch(git_p_patch, pkg_p_patch):
                c_pt.append(fname)
                print("Changed:", fname)

        git_filenames = [os.path.basename(p_set[1]) for p_set in git_patches]
        for p_set in pkg_patches:
            idx, ref, fname, doc, cond = p_set
            if fname not in git_filenames:
                r_pt.append(fname)
                print("Removed:", fname)

        return n_pt, c_pt, r_pt
        for e in self._sp.get_patch_executors():
            print(e)

    def _process(self):
        repo = self._git.clone()
        self._git.fetch(repo)
        self._git.checkout(repo)

        patches_dir = os.path.join(self._scenario['git']['repo-full-path'], '.patches')
        if not os.path.exists(patches_dir):
            os.makedirs(patches_dir)
        self._git._config['patches-dir'] = patches_dir  # Not good.

        patches = self._git.make_patches(repo, tag='vTest')
        self._git.gen_changelog(repo, patches)


class SpecException(Exception):
    '''
    Spec Exception
    '''


class SpecProcess(object):
    '''
    Spec parsing, extracting objects etc.

    '''
    def __init__(self, spec_path):
        self._spec_path = spec_path
        self._spec = spec.Spec.from_file(self._spec_path)
        self._spec_src = open(spec_path).read().split(os.linesep)
        self._patch_map = []

    def _get_patch_comment(self, patch_file):
        '''
        Get a comment for the particular patch file.

        :param patch_file:
        :return:
        '''
        comment = []
        idx = 0
        for line in self._spec_src:
            if patch_file in line:
                break
            idx += 1
        for idx in reversed(range(idx)):
            line = self._spec_src[idx]
            if line.startswith('#'):
                comment.append(line)
            else:
                break

        return os.linesep.join(reversed(comment))

    def get_patch_map(self):
        '''
        Get spec patch map along with the comments to each patch,
        assuming the comment belongs to the patch below it and has
        no empty lines in between.
        :return:
        '''
        if not self._patch_map:
            conditionals = self._parse_patch_executors()
            for patch_index, patch_name in enumerate(self._spec.patches_dict, 1):
                patch_ref = 'Patch{0}'.format(patch_index)
                patch_name = self._spec.patches_dict[patch_ref]
                self._patch_map.append((patch_index, patch_ref, patch_name,
                                        self._get_patch_comment(patch_name),
                                        conditionals.get('{0}'.format(patch_index))),)

        return self._patch_map

    def add_patch(self, filename, doc=None, condition=None):
        '''
        Add patch to the specfile patchmap.

        :param filename:
        :param doc:
        :return:
        '''
        def format_doc(msg):
            wrapper = textwrap.TextWrapper(initial_indent='# ',
                                           subsequent_indent='# ',
                                           break_on_hyphens=True,
                                           break_long_words=True,
                                           fix_sentence_endings=False,
                                           width=80)
            return os.linesep.join(wrapper.wrap(' '.join([item.strip() for item in msg.split(os.linesep)])))
        p_idx = len(self.get_patch_map()) + 1
        self._patch_map.append((p_idx, 'Patch{0}'.format(p_idx),
                                filename, format_doc(doc) if doc else '# N/A', condition),)

    def _parse_patch_executors(self):
        '''
        Parse patch executors from the spec file.

        :return:
        '''
        # Get conditions
        cnd_execs = {}
        for chunk in os.linesep.join(self._spec_src).split('%endif'):
            chunk = chunk.split('%if ')[-1]
            if '%patch' in chunk:
                chunk = [item for item in chunk.split(os.linesep) if item]
                if chunk:
                    condition = chunk.pop(0)
                    for patch_ref in chunk:
                        patch_ref = re.sub(r'\D', '', patch_ref.split(' ')[0])
                        cnd_execs[patch_ref] = condition
        return cnd_execs

    def get_patch_executors(self):
        '''
        Return a snippet of patch executors.
        :return:
        '''
        executors = []
        for idx, tag, filename, doc, condition in self.get_patch_map():
            if condition:
                executors.append('%if {0}'.format(condition))
                executors.append('%patch{0} -p1'.format(idx))
                executors.append('%endif')
            else:
                executors.append('%patch{0} -p1'.format(idx))

        return executors


class GitOpException(Exception):
    pass


class GitProcess(object):
    '''
    Git commands.
    '''
    IDX_PATCHES_FILE = '.patches-order'
    LOG_PATCHES_FILE = '.patches-changes'

    def __init__(self, config, flush_patches_dir=False):
        self._config = config
        if not self._config:
            raise Exception('Git is not configured!')

        for keycheck in ['repo-path', 'branch', 'url']:
            if keycheck not in self._config:
                raise Exception('The "{0}" directive is missing'.format(keycheck))
        name = self.get_repo_name(self._config['url'])
        self._config['repo-full-path'] = os.path.join(self._config['repo-path'], name)
        self._patch_map = []

        patches_dir = os.path.join(self._config['repo-full-path'], '.patches')
        if not os.path.exists(patches_dir):
            os.makedirs(patches_dir)
        self._config['patches-dir'] = patches_dir
        if flush_patches_dir:
            self._flush_patches_dir()

    def _flush_patches_dir(self):
        '''
        Flush patches directory.
        :return:
        '''
        for file_name in os.listdir(self._config['patches-dir']):
            os.unlink(os.path.join(self._config['patches-dir'], file_name))

    def get_repo_name(self, url):
        '''
        Get repository name from the url.
        :param url:
        :return:
        '''
        return url.split('/')[-1].split('.')[0]

    def clone(self):
        '''
        Prepare sources from the repository.
        '''
        if not os.path.exists(self._config['repo-full-path']):
            os.makedirs(self._config['repo-full-path'])
            git.Repo.clone_from(self._config['url'], self._config['repo-full-path'])

        return git.Repo(self._config['repo-full-path'])

    def checkout(self, repo, branch_name=None):
        '''
        Checkout an appropriate branch.

        :param branch:
        :return:
        '''
        branch_name = (branch_name or self._config['branch']).split("/")[-1]
        for remote in repo.remotes.origin.refs:
            if remote.name.split("/")[-1] == branch_name:
                repo.create_head(branch_name).checkout()
                repo.git.pull('origin', branch_name)

    def fetch(self, repo):
        '''
        Fetch the repo objects

        :param repo:
        :return:
        '''
        for remote in repo.remotes:
            remote.fetch()

    def _unique(self, fname):
        '''
        Change name to the unique, in case it isn't.

        :param fname:
        :param use:
        :return:
        '''
        fname = fname.split('.')
        if '-' not in fname[0]:
            fname[0] = '{0}-{1}'.format(fname[0], 1)
        else:
            chnk = fname[0].split('-')
            try:
                fname[0] = '{0}-{1}'.format('-'.join(chnk[:-1]), int(chnk[-1]) + 1)
            except ValueError as err:
                fname[0] = '{0}-{1}'.format(fname[0], 1)  # Filename is not in "str-int", but "str-str".

        return '.'.join(fname)

    def _remove_filename_order(self, filename):
        '''
        Remove order of the patch filename.

        Git formats patches: XXXX-filename.patch
        This function removes the "XXXX-" part, if any.
        '''
        b_fname = os.path.basename(filename)
        dir_name = os.path.dirname(filename)

        ordnum = b_fname.split('-')[0]
        if ordnum and not re.sub(r'[0-9]', '', ordnum):
            new_filename = os.path.join(dir_name, b_fname.split('-', 1)[-1]).lower()
            ordnum = int(ordnum)
        else:
            new_filename = filename
            ordnum = None

        return ordnum, filename, new_filename

    def _remove_body_order(self, src_file, dst_file, use_unique=False):
        '''
        Remove subject inside the patch.

        Git format patches inside with the following subject format:
        Subject: [PATCH X/Y] .........

        This function removes [PATCH X/Y] part, if any. In Git format-patches one can
        add "-N" flag, so then subject won't have these numbers, but just "[PATCH]".
        In this case we leave it out.
        '''

        if os.path.exists(dst_file) and not use_unique:
            raise IOError('the file {0} exists'.format(dst_file))

        if use_unique:
            dst_file = self._unique(dst_file)
        dst = open(dst_file, 'w')
        for fline in open(src_file).read().split(os.linesep):
            fline_tk = re.split(r'\s+\[PATCH \d+/\d+\]\s+', fline)
            if len(fline_tk) == 2 and fline_tk[0] == 'Subject:':
                fline = ' [PATCH] '.join(fline_tk)
            dst.write('{0}\n'.format(fline))
        dst.close()
        if os.path.exists(src_file):
            os.unlink(src_file)

    def _pack_order(self, paths):
        '''
        Remove order from the patches (subject, body, filename etc) and create an index file nearby.
        :param paths:
        :return:
        '''

        n_paths = []
        idx_file = open(os.path.join(self._config['patches-dir'], self.IDX_PATCHES_FILE), 'w')
        idx_file.write('# Patches involved:\n')
        for commit_id, patch_pth in paths:
            idx, current_fname, new_fname = self._remove_filename_order(patch_pth)
            self._remove_body_order(current_fname, new_fname)
            idx_file.write('Patch{0: <10}{1}\n'.format(str(idx) + ':', os.path.basename(new_fname)))
            n_paths.append((commit_id, new_fname,))
        idx_file.write('\n# Patching process:\n')
        for idx in range(len(paths)):
            idx_file.write('%patch{0} -p1\n'.format(idx + 1))
        idx_file.close()

        return n_paths

    def _get_physical_patch_id(self, path):
        '''
        Extracts a physical ID from the patch file.

        :param path:
        :return:
        '''
        commit_id = None
        if not os.access(path, os.R_OK):
            raise GitOpException("Unable to access '{0}' file".format(path))
        for line in open(path).readlines():
            line = line.strip().lower().split(' ')
            if len(line) > 1 and len(line[1]) == 40:
                commit_id = line[1]
                break

        return commit_id

    def get_patch_map(self, tag=None, clean=False):
        '''
        Get map of the patches in this repo.
        :return:
        '''
        if self._patch_map and not clean:
            return self._patch_map

        tag = tag or self._config.get('tag', None)
        if not tag:
            raise GitOpException('Tag needs to be specified till what to generate patches. '
                                 'Otherwise I will flood you!')
        repo = self.clone()
        self.checkout(repo)
        self.fetch(repo)
        self._patch_map = self.make_patches(repo, tag)

        return self._patch_map

    def make_patches(self, repo, tag, path=None):
        '''
        Make raw patches.

        :param repo:
        :param tag:
        :param path:
        :return:
        '''
        path = path or self._config.get('patches-dir', './')
        paths = repo.git.format_patch(tag, '-o', path).split('\n')
        for idx, p_pth in enumerate(paths):
            paths[idx] = (self._get_physical_patch_id(p_pth), p_pth)

        paths = self._pack_order(paths)  # Update names
        return paths

    def gen_changelog(self, repo, patches):
        '''
        Generate chanelog.

        :param repo:
        :param patches:
        :return:
        '''
        def _format_message(msg):
            '''
            Format message from anything to a changelog-compatible.

            :param msg:
            :return:
            '''
            wrapper = textwrap.TextWrapper(initial_indent='- ',
                                           subsequent_indent='  ',
                                           break_on_hyphens=True,
                                           break_long_words=True,
                                           fix_sentence_endings=False,
                                           width=67)
            out = []
            for line in msg.split('\n'):
                line = line.strip()
                if not line:
                    continue
                if not line.endswith("."):
                    line += '.'
                out.append(line[0].upper() + line[1:])
            return '\n'.join(wrapper.wrap(' '.join(out)))

        changelog = []
        for commit_id, patchfile in patches:
            commit = repo.commit(commit_id)
            changelog.append(_format_message(commit.message))

        changelog_file = open(os.path.join(self._config['patches-dir'], self.LOG_PATCHES_FILE), 'w')
        changelog_file.write(os.linesep.join(changelog) + os.linesep)
        changelog_file.close()

        return changelog


def remove_order(filename):
    '''
    Remove order of the patch filename.

    Git formats patches: XXXX-filename.patch
    This function removes the "XXXX-" part, if any.
    '''
    ordnum = os.path.basename(filename).split('-')[0]
    if ordnum and not re.sub(r'[0-9]', '', ordnum):
        filename = os.path.join(os.path.dirname(filename), filename.split('-', 1)[-1]).lower()
        ordnum = int(ordnum)
    else:
        ordnum = None

    return ordnum, filename


def remove_order_from_subject(src_file, dst_file, use_unique=False):
    '''
    Remove subject inside the patch.

    Git format patches inside with the following subject format:
    Subject: [PATCH X/Y] .........

    This function removes [PATCH X/Y] part, if any. In Git format-patches one can
    add "-N" flag, so then subject won't have these numbers, but just "[PATCH]".
    In this case we leave it out.
    '''

    if os.path.exists(dst_file) and not use_unique:
        raise IOError('the file {0} exists'.format(dst_file))

    if use_unique:
        dst_file = unique(dst_file)
    dst = open(dst_file, 'w')
    for fline in open(src_file).read().split(os.linesep):
        fline_tk = re.split(r'\s+\[PATCH \d+/\d+\]\s+', fline)
        if len(fline_tk) == 2 and fline_tk[0] == 'Subject:':
            fline = ' [PATCH] '.join(fline_tk)
        dst.write('{0}\n'.format(fline))
    dst.close()


def git_format_patch(tag):
    '''
    Formats patches from the given tag.
    '''
    patches = 0
    for patch in os.popen('git format-patch {0}'.format(tag)).read().split(os.linesep):
        if patch.split('.')[-1] == 'patch':
            patches += 1

    print("Patches fetched: {0}".format(patches))


def get_diff_contents(data):
    '''
    Get diff contents only.
    '''
    # Yes, I know about library https://github.com/cscorley/whatthepatch
    # But for now we go ultra-primitive to keep no deps
    data = '--'.join(data.split("--")[:-1])
    contents = []
    for chunk in re.split(r'@@.*?@@.*?\n', data)[1:]:
        contents.append(chunk.split('diff --git')[0])

    return contents


def unique(fname):
    '''
    Change name to the unique, in case it isn't.

    :param fname:
    :param use:
    :return:
    '''
    fname = fname.split('.')
    if '-' not in fname[0]:
        fname[0] = '{0}-{1}'.format(fname[0], 1)
    else:
        chnk = fname[0].split('-')
        try:
            fname[0] = '{0}-{1}'.format('-'.join(chnk[:-1]), int(chnk[-1]) + 1)
        except ValueError as err:
            fname[0] = '{0}-{1}'.format(fname[0], 1)  # Filename is not in "str-int", but "str-str".

    return '.'.join(fname)


def extract_spec_source_patches(specfile):
    '''
    Extracts source patches from the .spec file to match existing comments,
    according to the https://en.opensuse.org/openSUSE:Packaging_Patches_guidelines

    :param: specfile
    :return:
    '''
    patch_sec_start = False
    patch_sec_end = False
    head_buff = []
    patch_section = []
    for spec_line in open(specfile).read().split(os.linesep):
        if re.match(r'^[Pp]atch[0-9]+:', spec_line) and not patch_sec_start:
            patch_sec_start = True

        if not spec_line.startswith('#') and not re.match(r'^[Pp]atch[0-9]+:', spec_line) and patch_sec_start and not patch_sec_end:
            patch_sec_end = True

        if not patch_sec_start and not patch_sec_end:
            head_buff.append(spec_line)

        if patch_sec_start and not patch_sec_end:
            patch_section.append(spec_line)

    first_comment = []
    for head_line in reversed(head_buff):
        if not head_line:
            break
        if head_line.startswith('#'):
            first_comment.append(head_line)
    patch_section.insert(0, os.linesep.join(first_comment))

    patchset = {}
    curr_key = None
    for line in reversed(patch_section):
        if re.match(r'^[Pp]atch[0-9]+:', line):
            curr_key = re.sub(r'^[Pp]atch[0-9]+:', '', line).strip()
            patchset[curr_key] = []
            continue
        if curr_key and line and line.startswith('#'):
            patchset[curr_key].append(line)

    return patchset


def do_remix_spec(args):
    '''
    Remix spec file.

    :param args:
    :return:
    '''
    if not os.path.exists(args.spec or ''):
        raise IOError('Specfile {0} is not accessible or is somewhere else'.format(args.spec))
    if not os.path.exists(args.ordering or ''):
        args.ordering = './{0}'.format(ORDERING_FILE)
        if not os.path.exists(args.ordering):
            raise IOError('Ordering file is expected "./{0}" but is not visible'.format(ORDERING_FILE))

    patchset = extract_spec_source_patches(args.spec)
    for o_line in open(args.ordering).read().split(os.linesep):
        if re.match(r'^[Pp]atch[0-9]+:', o_line):
            ref, pname = filter(None, o_line.split(' '))
            print(os.linesep.join(patchset.get(pname) or ['# Description N/A']))
            print(ref.ljust(15), pname)


def do_create_patches(args):
    '''
    Create and reformat patches for the package.
    '''
    current_dir = os.path.abspath('.')

    if not args.existing:
        if os.listdir(current_dir):
            print("Error: this directory has to be empty!")
            sys.exit(1)

        git_format_patch(args.format)
    else:
        if not [fname for fname in os.listdir(current_dir) if fname.endswith('.patch')]:
            print("Error: can't find a single patch in {0} to work with!".format(current_dir))
            sys.exit(1)

    ord_fh = open(args.ordering or ORDERING_FILE, 'w')
    ord_fh.write('#\n#\n# This is pre-generated snippets of patch ordering\n#\n')
    ord_patches_p = []

    patches = 0
    for fname in os.listdir(current_dir):
        if fname.split('.')[-1] == 'patch':
            print("Preparing", fname)
            order, nfname = remove_order(fname)
            if args.index is not None:
                order += args.index
            remove_order_from_subject(fname, nfname, use_unique=args.increment)
            os.unlink(fname)
            ord_fh.write('{patch}{fname}\n'.format(patch='Patch{0}:'.format(order).ljust(15), fname=nfname))
            ord_patches_p.append(order)

            patches += 1

    if ord_patches_p:
        ord_fh.write('#\n#\n# Patch processing inclusion:\n')
        for order in ord_patches_p:
            ord_fh.write('%patch{num} -p1\n'.format(num=order))
    else:
        ord_fh.write('# Nothing here, folks... :-(\n')

    ord_fh.close()

    print("\nRe-formatted {0} patch{1}".format(patches, patches > 1 and 'es' or ''))


def do_update_patches(args):
    '''
    Update patches on the target package source.
    '''
    print("Updating packages from {0} directory".format(args.update))
    added = []
    removed = []
    changed = []

    # Gather current patches
    current_patches = {}
    for fname in os.listdir(os.path.abspath(".")):
        if fname.endswith('.patch'):
            current_patches[os.path.basename(fname)] = True

    for fname in os.listdir(args.update):
        if fname.endswith('.patch'):
            fname = os.path.join(args.update, fname)
            if os.path.isfile(fname):
                current_patches[os.path.basename(fname)] = False
                n_fname = os.path.basename(fname)
                if not os.path.exists(n_fname):
                    print("Adding {0} patch".format(fname))
                    shutil.copyfile(fname, os.path.join(os.path.abspath("."), n_fname))
                    added.append(n_fname)
                else:
                    if get_diff_contents(open(fname).read()) != get_diff_contents(open(n_fname).read()):
                        if args.changed:
                            print("Replacing {0} patch".format(n_fname))
                            os.unlink(n_fname)
                            shutil.copyfile(fname, os.path.join(os.path.abspath("."), n_fname))
                            changed.append(n_fname)
                        else:
                            print("WARNING: Patches {0} and {1} are different!".format(fname, n_fname))

    for fname in sorted([patch_name for patch_name, is_dead in current_patches.items() if is_dead]):
        print("Removing {0} patch".format(fname))
        os.unlink(fname)
        removed.append(fname)

    # Generate an include for spec changes
    changes = open(CHANGES_FILE, "w")
    for title, data in [('Changed', changed), ('Added', added), ('Removed', removed)]:
        if not data: continue
        print >> changes, "- {0}:".format(title)
        for fname in sorted(data):
            print >> changes, "  * {0}".format(fname)
        print >> changes

    if not removed and not added and not changes:
        print("No files has been changed")

    changes.close()


def get_cli_params():
    parser = argparse.ArgumentParser(description='Git-based patch automation service for packages')
    parser.add_argument('-r', '--repo', action='store', const=None,
                        help='Git repository to generate patches from')
    parser.add_argument('-f', '--format', action='store', const=None,
                        help='specify tag or range of commits for patches to be formatted')
    parser.add_argument('-s', '--spec', action='store', const=None,
                        help='specify package spec file')
    parser.add_argument('-v', '--version', action='store_const', const=True,
                        help='show version')
    parser.add_argument('-c', '--config', action='store', const=None,
                        help='Automation config file')
    parser.add_argument('-d', '--debug', action='store_const', const=True,
                        help='Debug (show actual traceback)')
    args = parser.parse_args()
    return args, parser


def main():
    '''
    Main app.
    '''
    VERSION = '0.1'
    args, parser = get_cli_params()
    try:
        # Check environment
        for mod, mod_descr in [(yaml, 'YAML'), (wtp, 'Patch parser (whatthepatch)'),
                               (git, 'python-git (GitPython)')]:
            if mod is None:
                raise Exception("{0} module is not installed.".format(mod_descr))

        if args.version:
            print("Version: {0}".format(VERSION))
            sys.exit(1)

        config = {}
        if args.config:
            config = yaml.load(open(args.config).read())

        if not config:
            parser.print_help()
        else:
            mixer = Git2OSCMixer(config)
            mixer.process()

    except Exception as ex:
        print("Critical error:", ex, file=sys.stderr)
        if args.debug:
            raise


if __name__ == '__main__':
    main()
